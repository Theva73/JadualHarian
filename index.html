<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Weekly Schedule (robust XML loader)</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;margin:20px}
  h2{margin-top:0}
  .controls{margin-bottom:1rem;display:flex;gap:.5rem;flex-wrap:wrap}
  button{padding:.5rem .9rem;font-size:.9rem;cursor:pointer;border:1px solid #888;border-radius:4px;background:#fafafa}
  button:disabled{opacity:.5;cursor:not-allowed}
  input[type=file]{display:none}
  table{border-collapse:collapse;width:100%;min-width:640px}
  th,td{border:1px solid #ccc;padding:6px;text-align:center;vertical-align:top}
  th{background:#f0f0f0}
  tr:nth-child(even){background:#fafafa}
  small{display:block;color:#555;font-size:.8em}
  hr{border:0;border-top:1px dotted #ccc;margin:.3em 0}
  .table-wrapper{overflow-x:auto}
</style>
</head>
<body>

<h2>Weekly Schedule</h2>
<div class="controls">
  <input type="file" id="xmlFileInput" accept=".xml">
  <button id="uploadBtn">Upload XML</button>
  <button id="clearBtn" disabled>Clear Schedule</button>
</div>

<div id="scheduleContainer" class="table-wrapper"></div>

<script>
/* ---------- DOM hooks ---------- */
const xmlInput  = document.getElementById('xmlFileInput');
const uploadBtn = document.getElementById('uploadBtn');
const clearBtn  = document.getElementById('clearBtn');
const wrap      = document.getElementById('scheduleContainer');

uploadBtn.addEventListener('click', () => xmlInput.click());
xmlInput.addEventListener('change', handleFile);
clearBtn.addEventListener('click', clearSchedule);

/* ---------- file->table pipeline ---------- */
function handleFile(){
  const f = xmlInput.files?.[0];
  if(!f) return;
  const r = new FileReader();
  r.onload = e=>{
    try{
      const doc  = new DOMParser().parseFromString(e.target.result,'text/xml');
      const data = extractScheduleData(doc);
      renderTable(data);
      clearBtn.disabled=false;
    }catch(err){
      alert('Unable to parse timetable: '+err.message);
    }
  };
  r.readAsText(f);
}

/* ---------- resilient extractor ---------- */
function extractScheduleData(doc){
  const T = t => [...doc.getElementsByTagName(t),...doc.getElementsByTagName(t.toUpperCase())];

  /* ---- DAYS ---- */
  let dayNodes = T('day').filter(n=> n.parentElement &&
                                     n.parentElement.tagName.toLowerCase().includes('day')); // keep only catalogue, not <card><day>
  if(!dayNodes.length) dayNodes = T('daydefs').flatMap(n=>T.call(n,'day'));        // aSc variant
  const days = dayNodes.map(n=>{
    return n.getAttribute('long')  || n.getAttribute('name') ||
           n.getAttribute('short') || n.textContent.trim();
  }).filter(Boolean);

  /* if still empty → build synthetic list from card IDs */
  let dayIndexLookup = {};
  if(!days.length){
    const ids = [...new Set( T('card').flatMap(c=>{
      const d = c.querySelector('day,dayid,Day'); return d? [+d.textContent]:[];
    }))].sort((a,b)=>a-b);
    ids.forEach((id,i)=> dayIndexLookup[id]=i);
    ids.forEach((_,i)=> days.push('Day '+(i+1)));
  }

  /* ---- PERIODS ---- */
  let periodNodes = T('period').filter(n=> n.parentElement &&
                                           n.parentElement.tagName.toLowerCase().includes('period'));
  const periods = periodNodes.map(p=>{
    const start = p.getAttribute('starttime')||p.getAttribute('start')||
                  p.querySelector('starttime,start,Start')?.textContent||
                  p.getAttribute('name')||'';
    const end   = p.getAttribute('endtime')  ||p.getAttribute('end')  ||
                  p.querySelector('endtime,end,End')?.textContent   ||'';
    return {start,end};
  });
  if(!periods.length) throw new Error('No <period> tags found');

  /* ---- TABLE scaffold ---- */
  const table = Array.from({length:periods.length},
                ()=>Array.from({length:days.length},()=>[]));

  T('card').forEach(card=>{
    const dNode = card.querySelector('day,dayid,Day');
    const pNode = card.querySelector('period,Period');
    if(!dNode||!pNode) return;

    const rawDay = +dNode.textContent;
    const rawPer = +pNode.textContent;
    const dayIdx = dayIndexLookup[rawDay] ?? rawDay; // fallback if synthetic days list
    if(!table[rawPer] || table[rawPer][dayIdx]===undefined) return;

    const subj = (card.querySelector('subject,subj,Subject')||{}).textContent?.trim()||'—';
    const tch  = (card.querySelector('teacher,teacher1,staff,Teacher')||{}).textContent?.trim()||'';
    table[rawPer][dayIdx].push({subject:subj,teacher:tch});
  });

  return {days,periods,table};
}

/* ---------- renderer ---------- */
function renderTable({days,periods,table}){
  wrap.innerHTML='';
  const tbl=document.createElement('table');

  /* header */
  const thead = tbl.createTHead(), hrow=thead.insertRow();
  hrow.insertCell().outerHTML='<th>Time</th>';
  days.forEach(d=>hrow.insertCell().outerHTML=`<th>${d}</th>`);

  /* body */
  const tbody = tbl.createTBody();
  periods.forEach((per,r)=>{
    const tr=tbody.insertRow();
    tr.insertCell().innerHTML=`${per.start}&nbsp;–&nbsp;${per.end}`;
    days.forEach((_,c)=>{
      const cell=tr.insertCell();
      const slot=table[r][c];
      if(slot.length){
        cell.innerHTML=slot.map(s=>`${s.subject}<br><small>${s.teacher}</small>`).join('<hr>');
      }
    });
  });

  wrap.appendChild(tbl);
}

/* ---------- utilities ---------- */
function clearSchedule(){
  wrap.innerHTML='';
  clearBtn.disabled=true;
  xmlInput.value='';
}
</script>
</body>
</html>